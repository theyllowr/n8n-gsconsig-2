name: Build and Push n8n Custom to GCR

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Permite executar manualmente
    inputs:
      n8n_version:
        description: 'N8N version to build (e.g., latest, 1.65.2)'
        required: false
        default: 'latest'

env:
  GCP_PROJECT_ID: n8ngsconsig
  GCR_HOSTNAME: gcr.io
  IMAGE_NAME: n8n-bypassed

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      id-token: write

    steps:
      - name: ðŸ“¥ Checkout n8n-bypass repository
        uses: actions/checkout@v4

      - name: ðŸ” Determine N8N version
        run: |
          N8N_VERSION="${{ github.event.inputs.n8n_version || 'latest' }}"
          echo "N8N_VERSION=$N8N_VERSION" >> $GITHUB_ENV
          echo "âœ… Will build n8n version: $N8N_VERSION"

      - name: ðŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ðŸ› ï¸ Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: ðŸ”§ Configure Docker for GCR
        run: |
          gcloud auth configure-docker gcr.io

      - name: ðŸ“ Create patch script
        run: |
          mkdir -p /tmp/n8n-custom
          cat > /tmp/n8n-custom/apply-patches.sh << 'PATCH_EOF'
          #!/bin/sh
          set -e
          
          echo "ðŸ©¹ Applying license bypass patches..."
          
          # Patch 1: license.js - MÃ©todo isLicensed (bypass global)
          LICENSE_FILE="/usr/local/lib/node_modules/n8n/dist/license.js"
          if [ -f "$LICENSE_FILE" ]; then
            echo "ðŸ“ Patching $LICENSE_FILE..."
            
            # Bypass isLicensed - retornar sempre true
            sed -i 's/isLicensed(feature) {$/isLicensed(feature) { return true; \/\/ BYPASS/' "$LICENSE_FILE"
            
            # Bypass getPlanName - retornar "Enterprise" ao invÃ©s de "Community"
            sed -i "s/return this\.getValue('planName') ?? 'Community';/return 'Enterprise'; \/\/ BYPASS/" "$LICENSE_FILE"
            
            # Bypass getConsumerId - retornar um ID vÃ¡lido
            sed -i "s/return this\.manager?.getConsumerId() ?? 'unknown';/return 'enterprise-bypass'; \/\/ BYPASS/" "$LICENSE_FILE"
            
            # Bypass isWithinUsersLimit - sempre true
            sed -i 's/isWithinUsersLimit() {$/isWithinUsersLimit() { return true; \/\/ BYPASS/' "$LICENSE_FILE"
            
            # Bypass getValue - implementar lÃ³gica completa de bypass de quotas
            # Encontrar a linha do mÃ©todo getValue e adicionar o bypass completo
            awk '/getValue\(feature\) \{/{
              print
              print "        if (feature.toString().includes(\"quota\")) { return -1; }"
              next
            }1' "$LICENSE_FILE" > "$LICENSE_FILE.tmp" && mv "$LICENSE_FILE.tmp" "$LICENSE_FILE"
            
            # Bypass SHOW_NON_PROD_BANNER - esconder banner de nÃ£o produÃ§Ã£o
            awk '/isLicensed\(feature\) \{/{
              print
              print "        if (feature === \"feat:sharing\") { return false; }"
              next
            }1' "$LICENSE_FILE" > "$LICENSE_FILE.tmp" && mv "$LICENSE_FILE.tmp" "$LICENSE_FILE"
            
            echo "âœ… license.js patched (isLicensed, getPlanName, getConsumerId, isWithinUsersLimit, getValue with quota bypass)"
          else
            echo "âš ï¸  $LICENSE_FILE not found"
          fi
          
          # Patch 2: license-state.js - Bypass adicional
          LICENSE_STATE_FILE="/usr/local/lib/node_modules/n8n/node_modules/@n8n/backend-common/dist/license-state.js"
          if [ -f "$LICENSE_STATE_FILE" ]; then
            echo "ðŸ“ Patching $LICENSE_STATE_FILE..."
            sed -i 's/isLicensed(feature) {$/isLicensed(feature) { return true; \/\/ BYPASS ADICIONAL/' "$LICENSE_STATE_FILE"
            echo "âœ… license-state.js patched"
          else
            echo "âš ï¸  $LICENSE_STATE_FILE not found, trying alternative paths..."
            # Tentar outros caminhos possÃ­veis
            find /usr/local/lib/node_modules -name "license-state.js" -type f 2>/dev/null | while read file; do
              echo "ðŸ“ Found and patching: $file"
              sed -i 's/isLicensed(feature) {$/isLicensed(feature) { return true; \/\/ BYPASS ADICIONAL/' "$file" 2>/dev/null || true
            done
          fi
          
          echo "ðŸŽ‰ All patches applied!"
          PATCH_EOF
          
          chmod +x /tmp/n8n-custom/apply-patches.sh

      - name: ðŸ“ Create custom Dockerfile
        run: |
          cat > /tmp/n8n-custom/Dockerfile << 'DOCKERFILE_EOF'
          ARG N8N_VERSION=latest
          FROM n8nio/n8n:${N8N_VERSION}
          
          USER root
          
          # Copiar e executar script de patch
          COPY apply-patches.sh /tmp/apply-patches.sh
          RUN chmod +x /tmp/apply-patches.sh && \
              /tmp/apply-patches.sh && \
              rm /tmp/apply-patches.sh
          
          USER node
          
          LABEL maintainer="GSConsig"
          LABEL description="N8N with enterprise license bypass"
          LABEL version="${N8N_VERSION}"
          DOCKERFILE_EOF

      - name: ðŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ³ Build Docker image (AMD64 only)
        run: |
          cd /tmp/n8n-custom
          
          IMAGE_TAG="${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ env.N8N_VERSION }}"
          IMAGE_TAG_LATEST="${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest"
          
          echo "ðŸ—ï¸ Building Docker image (linux/amd64): $IMAGE_TAG"
          echo "ðŸ“¦ Base image: n8nio/n8n:${{ env.N8N_VERSION }}"
          
          docker buildx build \
            --platform linux/amd64 \
            --tag "$IMAGE_TAG" \
            --tag "$IMAGE_TAG_LATEST" \
            --build-arg N8N_VERSION="${{ env.N8N_VERSION }}" \
            --file Dockerfile \
            --load \
            .
          
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "IMAGE_TAG_LATEST=$IMAGE_TAG_LATEST" >> $GITHUB_ENV

      - name: ðŸš€ Push to GCR
        run: |
          echo "ðŸ“¤ Pushing images to GCR (gcr.io)..."
          
          docker push ${{ env.IMAGE_TAG }}
          docker push ${{ env.IMAGE_TAG_LATEST }}
          
          echo "âœ… Images pushed successfully!"
          echo "ðŸ“¦ Image: ${{ env.IMAGE_TAG }}"
          echo "ðŸ“¦ Latest: ${{ env.IMAGE_TAG_LATEST }}"

      - name: ðŸ“Š Summary
        run: |
          echo "## ðŸŽ‰ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Image Details" >> $GITHUB_STEP_SUMMARY
          echo "- **N8N Version:** ${{ env.N8N_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** \`${{ env.IMAGE_TAG }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest Tag:** \`${{ env.IMAGE_TAG_LATEST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Applied Patches" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… License bypass (global)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Quota bypass (unlimited)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… License state bypass" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pull Command" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ env.IMAGE_TAG_LATEST }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
